use lsp_types::Range;
use serde::{Deserialize, Serialize};
use serde_with::SerializeDisplay;

use crate::parser::COMMENT_PREFIX;

#[derive(Deserialize, Debug, thiserror::Error, Clone, Eq, PartialEq, SerializeDisplay)]
pub enum ParseErrorType {
    // Blocks tree building errors
    #[error("The '{0}' key can be only used under a `{1}`")]
    WrongKeyPosition(String, String),
    #[error("The '{0}' key can only be used once {level}", level = if *.1 == 0 {"in document root"} else {"at this level"})]
    DuplicatedKey(String, u8),
    #[error("Invalid multiline content found after the '{0}' key which is single line")]
    InvalidMultilineContent(String),
    #[error(
        "This content is not associated to any valid key.\nHint: maybe this should be a comment starting with {} or it needs a valid key as a prefix?",
        COMMENT_PREFIX
    )]
    ContentOutOfKey,
    #[error("Missing required key '{0}'")]
    MissingRequiredKey(String),
    #[error("Missing a value for the required key '{0}'")]
    MissingRequiredValue(String),

    /// An error generated by the FromDYBlock::from_block_with_validation()
    #[error("{0}")]
    ValidationError(String),
}

/// Implement ordering to sort errors by range start position.
/// This makes it easier for testing and also better for console output
impl Ord for ParseError {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        (self.range.start.line, self.range.start.character)
            .cmp(&(other.range.start.line, other.range.start.character))
    }
}

impl PartialOrd for ParseError {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other)) // just use normal Ord trait
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq)]
#[typeshare::typeshare]
pub struct ParseError {
    pub range: Range,
    pub error: ParseErrorType,
}
